import random
import tqdm
import sys
sys.path.append('W3')

from Six import FormTheMatrix
from Five_one import ProfileMostProbableK_mer

def Score(Motifs):
    count = 0
    L = Consensus(Motifs)
    for i in Motifs:
        for chr1, chr2 in zip(i,L):
            if chr1 != chr2:
                count += 1
    return count
def Consensus(Motifs):
    # insert your code here
    k = len(Motifs[0])
    count = Count(Motifs)
    consensus = ""
    for j in range(k):
        m = 0
        frequentSymbol = ""
        for symbol in "ACGT":
            if count[symbol][j] > m:
                m = count[symbol][j]
                frequentSymbol = symbol
        consensus += frequentSymbol
    return consensus
def Count(Motifs):
    count = {}
    for i in 'ACGT':
        count[i] = []
        for ii in range(len(Motifs[0])):
            count[i].append(0)
    for i in range(len(Motifs)):
        for j in range(len(Motifs[0])):
            symbol = Motifs[i][j]
            count[symbol][j] += 1
    #for symbol in count:
        ##count[symbol][kk] = count[symbol][kk]/len(Motifs)
    return count

def Motifs(profile, Dna):
    """given a profile and an dna list, outputs the k-mers that are most probable with the profile in that dna

    Args:
        profile (list): a 2-D list of probabilty of each nucleotide
        Dna (list): list of string (dna)

    Returns:
        list: list of best k-mers 
    """    
    k = len(profile[0])
    motif = []
    for text in Dna:
        motif.append(ProfileMostProbableK_mer(text,k,profile))
    return motif

def RandomizedMotifSearch(Dna, k, t):
    """Randomly select k-mers and try to iterate until the score converges on a minimal point. we also use pseudo counts

    Args:
        Dna (list): list of strings (dna)
        k (int): as in k-mer
        t (int): iteration 

    Returns:
        list: list of best k-mers (repetitive ones in each dan)
    """    
    # for k in range(1000):
    motif = []
    for s in range(len(Dna)):
        rnd = random.randint(0,len(Dna[0])-k)
        motif.append(Dna[s][rnd:rnd+k])

    BestMotifs = motif[:]

    for i in range(t):
        profile = FormTheMatrix(motif)
        motif = Motifs(profile, Dna)
        
        if Score(motif) < Score(BestMotifs):
            BestMotifs = motif[:]
            
            sorat = len(set(BestMotifs) & set(truth))
            makh = float(len(set(BestMotifs) | set(truth)))
            res = (sorat/makh )*100
            if res == 100:
                print("Percent: ",res)
                print("inner score:", Score(motif))
        else:
            return BestMotifs
    # return BestMotifs


truth = """AAGTACCCCTCATAT
ACCTACCCCTCATAA
CATAACCCCTCATAT
CGCCCGCCCTCATAT
CGCGTGCCCTCATAT
CGCTAAATCTCATAT
CGCTACAGATCATAT
CGCTACCATGCATAT
CGCTACCCCAACTAT
CGCTACCCCTCAGTG
CGCTACCCCTCGGCT
CGCTACCCCTTTCAT
CGCTACCCTATATAT
CGCTACGTATCATAT
CGCTAGAACTCATAT
CGCTGGACCTCATAT
CGCTGGTCCTCATAT
CGGACCCCCTCATAT
CTATACTCATTAGAT
TGCTACCCCTCATGC""".split(sep="\n")
truth=list(truth)
truth.sort()
if __name__ == "__main__":

    random.seed(2021)

    dna = """CCGGTTAACTCGTTCAGGATCTGGCATGACGTACTAGGTAGCGAAACTCATTCCAGTCCGGGTTGGTTTTGCCCATTATAGCCCAGTGCGGTTTGTAACGTGTGTATCTAGAGTACCAACGCGCTATGGCAATCCCAGATAGTTTAGTTACTACCCTGCAAATTGTTTAGCGGGCAGGGCGCAAGCCGGTTAACTCGTTC
AGGATCTGGCATGACGTACTAGGTAGCGAAACTCATTCCAGTCCGGGTTGGTTTTGCCCATTATAGCCCAGTGCGGTTTGTAACGTGTGTATCTAGAGTACCAACGCGCTATGGCAATCGTGTGGTATCCCTTCCCAGATAGTTTAGTTACTACCCTGCAAATTGTTTAGCGGGCAGGGCGCAAGCCGGTTAACTCGTTC
AGTCTTGTTACCCACCGACTGGGCACGCCCTAACCTGACACGCTGTCAAGTATCCCGGAAGAAAAACAAGACCGGAGTCCGGTAACTTCTGATGCCCCGAGACTGCCGTAACGGTACCGTCCTCACTGTGCTAACCAGCGGTACACCAATCTGTCTGGTAGAAACGCCTCATATCCCCAGAACGGAATAGGCCCCATACC
CAACTAGGCCAGGCCACTTTGGTGATACATCCGAGCATCTCGACCAGGAGATAGCCTCTGATACACGCTTGCGTTCCGTATCCCTTCCCTGGTCGTGGCGGATAGCACCCCTAAAATTGTGAGATTGTCTGGAAGCCGGGATCTAAACAGAAATCGGGGATGTTGGAATTAGCCCAGTCGTATAACTATTTGGTACCGGG
CGACTCAACCCAATTCCGCCCGAGCTCTGCGTAGTACCTAGCTTAGTCAAAGATCTATAACCAACCTCGGCTCGCACTTGGACTAGGAAACTTCGACCAAGCAACCCCTGGGCTTCGTGGGGTCTTGTAACGTCAACACTCCCTTTAGTGAGTCATCCTATTTTGCTTACTCGCGTTAACGCTTGCCTTACCTATAAGAC
TAAGGGAGATGGTATTCGCCGTTTGGTCGGGTAGGGATTGTTGTTGGCCACTGTACGGGTCGCGCGTTGCAGGGTGGATCAAGCATGGATCTCTTCAGTAACTCCCCTCACATTCATACCGGACACACGTCCTCGTACGGTCTCGCTATTACCGACAACGCTCTCGAGCTCCACGTCCTATATCCCTTATGGACATCATC
TTCCACGGCCGCTCTCTGTGATCAAGTATCCCTCAGTGTTCGCCATTCGGCCAAGCGGGCCAAAGGGGTGGCTATTAGAGGAAATCAGTTAGGACCTATCAAGAGTAGTTTCAGGCCCTACTATCATTGTGTCCTTTCTGGAACAATGGCAGTGCGTAGCCTCCTCAGCGACCAGAGTTGTACCCTTTGACCGACTTGAC
TGTACGATGCATGCCGCTTCCATCCAAGTATCCCTTCATAGCGAAATTTCGCGCGTGGGCGTCCAGGACAAATGCGATTGCTAATCTCGGTGCGCCATATCGCCATGGAATTACAGCGAGACGGCATGAGTAGTTAGATCTAGCACCCAGGGTGCAACGCTTGAGGGCGGATGTGCAGCTGTTGAAGCCGGGCAGCAGGA
TCACAAAGAAAATGGGGATTCCAAGAGACATGCGTGATATATATAGCATTAGTGGAAGATTGATTGAAAACACGAACTGCCGTCAAGTTGGCCTTTGACCACGCTATTGTAAGACTCTCCTACACCATGTGGTCCGTGCCATCAGCGGTAGAAAATGTCTATAGGACGATCATTGACATTGCGAGTTCGGCTGACGCCTG
GCGAATCCTAGCAGAGCATTCCTCGAGCGGGGGTCGCTAAGAAACGGAACGAGGGGCTGATTTTGCATCAAGATGAGAAGCGTCGACGCTGCGTCAAGTATTAATTTAAATCTGTTTTGCCGTTTCTGACAAAGACTGTCGTCCAACTTGACCGGCGGGGTATTTTACCGCGCCAGGACCGCATCTTCCATAACCTCGGT
CTGCGCGGCACGTCAAGTAAGGCTTATCCCTTCAGTCGGCGTAGATCCGAGCTCTTTCGCTGGCTGCATGTAGTTACTGTCCTGTATGGAGTCCGGCCTGCACTTGTCGCAGTTCGAGGATGGCGATACCCACCCTCATTGCGGATGAATACTGGTAATTAAGACCGCGATAGATACCCTAAGATCTTTGGTTGCGCGTT
TATGGAAAAGCGTCAAGTATCAGGTGCCAACATAGTGGGGTTGCCCCCTGACCTCAGCGCCAATACCGAGTTTATACTGACTGTCCTCATGCTGGTTTTATGGTCTGCAACCTCCGTTTGAGCTACCAAACAGCCCCAATCAATCAAGAGGCTTAAGGAAAACGCAGGAACTAAAAGGGGAAACCCGCAGAGAGGGTGTG
CCGCGACCTACTTGTCCGACGACCGTGCGACAGTGTCTGCGGGTCAGATCGGGCAGGGTATAATCTACTACCTGGTAACTCGCACGCGTCAATGTTCCCTTCCACACACCGTTTTACCGGCGCAGTCAAGATACCCGTCCGAGATGGCATCTTCGAGCCGACAGGATAGAAGCTCTTCGGAAAAGGTATGGGGCGAGGGA
GCGCCCCAACTATTTCCTCTGATCTGGTGGCTATTCAACTATAGGCTTCACGACGCCGAAATCAGTCCAACATAGACGATCATAACCGGTACCTATATCTTAATGGCGTCTGTTATCCCTTTAAGCCTACCGTCTGGGGGCGAAGCTACATAATCCACCAGTGTAAGTATAGCGTCGGGTAATTTGTCTAGAAGATTCTT
CCTGCCACCCCAAAGTCGCCATGCTCCGTTAACCGGAATTAGGCTAGGGTAATCCTCGCAGAGCGCTTGGTGATAGTCCTCCCAAAGTATCCCTTCTTGCGGGGCCAGAGAGTGCGTATGTGGTGGCAGTTATCTATGGATTGCGCTTGCTACAATGTCTAGACGAGGTCGTAGAAATCTGTTTCATGGAATGCGCTGTT
GGGTGTACCTACGTGCTTTGAATTTATGTCCGATGCGCTCAGTAACTTGTTCTCTCGATGATTTTCCGGTTATGTTTATTAGAACCCCATAAATCGACCTCGGCCTTGTTTTTGGTGGGTGCATACAAAGGAGGGCTTTGGCGGTTCGATCCTACTCGCGCAGTATCCCTTTCGCATGCTCTATGACGATTCCTGCTAGG
CTTATGCTCTACCAACGTCGTCAAGGCGCCCTTGCTTTTAGCCCACTTGAATACTCACTGAATAACAAGAATAAAACGGCGTGACACACCCCGGAGAGTAAAGACCGACCGGTTGTCACTGAGCTCGAGAAAGCGCCAGTATTCGGTAATGACAACGCTCTATTTTTAGAGCGACTAGGTATTATAATAGTGTACGGCGT
TGAAAAAAATACCGGGTCCCGAGCTGGAGGACGAACGGTCTGGATACTAATACTGACATTCAACCGCCAAGACGCTGACGTGACAACGCCTAACCAATCTCCTTCACTCATAATCGTCAAGTATCCTACTGGTAGAGCGTATTAAGGTACAGGCCCTTGTATACTGTATTGTCTGCACAGTTATGCAGAGGCCATCAGTA
ATAAATAAATGTGAACAAGGGGAGGCAAACAATGCTTTCGCAGGGCGAAATCCCCGTCGTGTACCTCTTTCCGCGAAGTCGGTAAAATAGGTAAAAACTAGGAATCTTACCATATTCGACGTCTATGGGCACCTAGGGCTCTGTTGTGGGGCAGTCTAGGCCCGCGGAAATGAGCAACGCCGCACGTCAGCAATCCCTTC
ACCATTTTTAGACGCATTTTTTTGAGACCGACAGGAGACATATTCACCCACAGATAGTATACCGGGAATGTTTGTATGACCGTCACCCATCCCTTATCTGGAACTTTTCCTCATCCCTATTCAGTCTAACCGGACCCGTTACACCATCATCACCAGATGACCCTTGTTGCGCTCTTCCTACATCTCTTCGTTATACCAAG"""
    
    li = RandomizedMotifSearch(dna.split(sep="\n"),15,20)
    sss = "CTATACTCATTAGAT CGCGTGCCCTCATAT CATAACCCCTCATAT CGCTACCCCTCGGCT CGCTACAGATCATAT CGCTAGAACTCATAT CGCCCGCCCTCATAT CGCTGGTCCTCATAT CGCTACCCCTTTCAT CGCTACGTATCATAT CGCTACCATGCATAT AAGTACCCCTCATAT CGCTACCCCTCAGTG TGCTACCCCTCATGC CGCTAAATCTCATAT CGCTACCCCAACTAT ACCTACCCCTCATAA CGCTGGACCTCATAT CGCTACCCTATATAT CGGACCCCCTCATAT".split()
    print("##########", sss == truth)
    for k in tqdm.tqdm(range(10)):

        best =  RandomizedMotifSearch(dna.split(sep="\n"),15,20)
        if Score(best) < Score(li):
            li = best[:]
            print("score: ", Score(best))
            sorat = len(set(li) & set(truth))
            makh = float(len(set(li) | set(truth)))
            res = (sorat/makh )*100
            print("Percent: ",res)
            if res == 100:
                print ("THIS IS K:",k)
                break
        # else:
            # break
    

    truth = """AAGTACCCCTCATAT
ACCTACCCCTCATAA
CATAACCCCTCATAT
CGCCCGCCCTCATAT
CGCGTGCCCTCATAT
CGCTAAATCTCATAT
CGCTACAGATCATAT
CGCTACCATGCATAT
CGCTACCCCAACTAT
CGCTACCCCTCAGTG
CGCTACCCCTCGGCT
CGCTACCCCTTTCAT
CGCTACCCTATATAT
CGCTACGTATCATAT
CGCTAGAACTCATAT
CGCTGGACCTCATAT
CGCTGGTCCTCATAT
CGGACCCCCTCATAT
CTATACTCATTAGAT
TGCTACCCCTCATGC""".split(sep="\n")

    truth=list(truth)

    # li.sort()
    truth.sort()
    # print(li)
    if li == truth:
        print(True)
    else:
        # print(li)
        # print(truth)
        for l in li:
            print(l)

    